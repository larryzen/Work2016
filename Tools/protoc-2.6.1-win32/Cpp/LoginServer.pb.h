// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LoginServer.proto

#ifndef PROTOBUF_LoginServer_2eproto__INCLUDED
#define PROTOBUF_LoginServer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace game {
namespace Protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LoginServer_2eproto();
void protobuf_AssignDesc_LoginServer_2eproto();
void protobuf_ShutdownFile_LoginServer_2eproto();

class ServerT;
class CMsRequsetLogin;
class CMsResponseLogin;
class CMsRegisterServer;
class CMsRegisterServerRet;
class CLMSTokeValidate;
class SMSTokeValidate;
class CMsgLogout;

// ===================================================================

class ServerT : public ::google::protobuf::MessageLite {
 public:
  ServerT();
  virtual ~ServerT();

  ServerT(const ServerT& from);

  inline ServerT& operator=(const ServerT& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerT& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerT* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerT* other);

  // implements Message ----------------------------------------------

  ServerT* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerT& from);
  void MergeFrom(const ServerT& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // required int32 number = 5;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 5;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // required int32 recommend = 6;
  inline bool has_recommend() const;
  inline void clear_recommend();
  static const int kRecommendFieldNumber = 6;
  inline ::google::protobuf::int32 recommend() const;
  inline void set_recommend(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.game.Protobuf.ServerT)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_recommend();
  inline void clear_has_recommend();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 port_;
  ::std::string* ip_;
  ::google::protobuf::int32 number_;
  ::google::protobuf::int32 recommend_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginServer_2eproto();
  friend void protobuf_ShutdownFile_LoginServer_2eproto();

  void InitAsDefaultInstance();
  static ServerT* default_instance_;
};
// -------------------------------------------------------------------

class CMsRequsetLogin : public ::google::protobuf::MessageLite {
 public:
  CMsRequsetLogin();
  virtual ~CMsRequsetLogin();

  CMsRequsetLogin(const CMsRequsetLogin& from);

  inline CMsRequsetLogin& operator=(const CMsRequsetLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CMsRequsetLogin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsRequsetLogin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsRequsetLogin* other);

  // implements Message ----------------------------------------------

  CMsRequsetLogin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsRequsetLogin& from);
  void MergeFrom(const CMsRequsetLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 loginType = 1;
  inline bool has_logintype() const;
  inline void clear_logintype();
  static const int kLoginTypeFieldNumber = 1;
  inline ::google::protobuf::int32 logintype() const;
  inline void set_logintype(::google::protobuf::int32 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // required string channelID = 4;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 4;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  inline void set_allocated_channelid(::std::string* channelid);

  // optional string devicesID = 5;
  inline bool has_devicesid() const;
  inline void clear_devicesid();
  static const int kDevicesIDFieldNumber = 5;
  inline const ::std::string& devicesid() const;
  inline void set_devicesid(const ::std::string& value);
  inline void set_devicesid(const char* value);
  inline void set_devicesid(const char* value, size_t size);
  inline ::std::string* mutable_devicesid();
  inline ::std::string* release_devicesid();
  inline void set_allocated_devicesid(::std::string* devicesid);

  // optional string sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline const ::std::string& sex() const;
  inline void set_sex(const ::std::string& value);
  inline void set_sex(const char* value);
  inline void set_sex(const char* value, size_t size);
  inline ::std::string* mutable_sex();
  inline ::std::string* release_sex();
  inline void set_allocated_sex(::std::string* sex);

  // optional string platform = 7;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 7;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // required string verison = 8;
  inline bool has_verison() const;
  inline void clear_verison();
  static const int kVerisonFieldNumber = 8;
  inline const ::std::string& verison() const;
  inline void set_verison(const ::std::string& value);
  inline void set_verison(const char* value);
  inline void set_verison(const char* value, size_t size);
  inline ::std::string* mutable_verison();
  inline ::std::string* release_verison();
  inline void set_allocated_verison(::std::string* verison);

  // optional string nickName = 9;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 9;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:com.game.Protobuf.CMsRequsetLogin)
 private:
  inline void set_has_logintype();
  inline void clear_has_logintype();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_devicesid();
  inline void clear_has_devicesid();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_verison();
  inline void clear_has_verison();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* account_;
  ::std::string* pwd_;
  ::std::string* channelid_;
  ::std::string* devicesid_;
  ::std::string* sex_;
  ::std::string* platform_;
  ::std::string* verison_;
  ::std::string* nickname_;
  ::google::protobuf::int32 logintype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginServer_2eproto();
  friend void protobuf_ShutdownFile_LoginServer_2eproto();

  void InitAsDefaultInstance();
  static CMsRequsetLogin* default_instance_;
};
// -------------------------------------------------------------------

class CMsResponseLogin : public ::google::protobuf::MessageLite {
 public:
  CMsResponseLogin();
  virtual ~CMsResponseLogin();

  CMsResponseLogin(const CMsResponseLogin& from);

  inline CMsResponseLogin& operator=(const CMsResponseLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CMsResponseLogin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsResponseLogin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsResponseLogin* other);

  // implements Message ----------------------------------------------

  CMsResponseLogin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsResponseLogin& from);
  void MergeFrom(const CMsResponseLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // required string gameID = 4;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 4;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // required string nickName = 5;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 5;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // repeated .com.game.Protobuf.ServerT serverlist = 6;
  inline int serverlist_size() const;
  inline void clear_serverlist();
  static const int kServerlistFieldNumber = 6;
  inline const ::com::game::Protobuf::ServerT& serverlist(int index) const;
  inline ::com::game::Protobuf::ServerT* mutable_serverlist(int index);
  inline ::com::game::Protobuf::ServerT* add_serverlist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::game::Protobuf::ServerT >&
      serverlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::game::Protobuf::ServerT >*
      mutable_serverlist();

  // @@protoc_insertion_point(class_scope:com.game.Protobuf.CMsResponseLogin)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* token_;
  ::std::string* account_;
  ::std::string* pwd_;
  ::std::string* gameid_;
  ::std::string* nickname_;
  ::google::protobuf::RepeatedPtrField< ::com::game::Protobuf::ServerT > serverlist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginServer_2eproto();
  friend void protobuf_ShutdownFile_LoginServer_2eproto();

  void InitAsDefaultInstance();
  static CMsResponseLogin* default_instance_;
};
// -------------------------------------------------------------------

class CMsRegisterServer : public ::google::protobuf::MessageLite {
 public:
  CMsRegisterServer();
  virtual ~CMsRegisterServer();

  CMsRegisterServer(const CMsRegisterServer& from);

  inline CMsRegisterServer& operator=(const CMsRegisterServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CMsRegisterServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsRegisterServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsRegisterServer* other);

  // implements Message ----------------------------------------------

  CMsRegisterServer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsRegisterServer& from);
  void MergeFrom(const CMsRegisterServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.game.Protobuf.ServerT server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline const ::com::game::Protobuf::ServerT& server() const;
  inline ::com::game::Protobuf::ServerT* mutable_server();
  inline ::com::game::Protobuf::ServerT* release_server();
  inline void set_allocated_server(::com::game::Protobuf::ServerT* server);

  // @@protoc_insertion_point(class_scope:com.game.Protobuf.CMsRegisterServer)
 private:
  inline void set_has_server();
  inline void clear_has_server();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::game::Protobuf::ServerT* server_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginServer_2eproto();
  friend void protobuf_ShutdownFile_LoginServer_2eproto();

  void InitAsDefaultInstance();
  static CMsRegisterServer* default_instance_;
};
// -------------------------------------------------------------------

class CMsRegisterServerRet : public ::google::protobuf::MessageLite {
 public:
  CMsRegisterServerRet();
  virtual ~CMsRegisterServerRet();

  CMsRegisterServerRet(const CMsRegisterServerRet& from);

  inline CMsRegisterServerRet& operator=(const CMsRegisterServerRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CMsRegisterServerRet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsRegisterServerRet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsRegisterServerRet* other);

  // implements Message ----------------------------------------------

  CMsRegisterServerRet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsRegisterServerRet& from);
  void MergeFrom(const CMsRegisterServerRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.game.Protobuf.CMsRegisterServerRet)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginServer_2eproto();
  friend void protobuf_ShutdownFile_LoginServer_2eproto();

  void InitAsDefaultInstance();
  static CMsRegisterServerRet* default_instance_;
};
// -------------------------------------------------------------------

class CLMSTokeValidate : public ::google::protobuf::MessageLite {
 public:
  CLMSTokeValidate();
  virtual ~CLMSTokeValidate();

  CLMSTokeValidate(const CLMSTokeValidate& from);

  inline CLMSTokeValidate& operator=(const CLMSTokeValidate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CLMSTokeValidate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CLMSTokeValidate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CLMSTokeValidate* other);

  // implements Message ----------------------------------------------

  CLMSTokeValidate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CLMSTokeValidate& from);
  void MergeFrom(const CLMSTokeValidate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:com.game.Protobuf.CLMSTokeValidate)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* token_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginServer_2eproto();
  friend void protobuf_ShutdownFile_LoginServer_2eproto();

  void InitAsDefaultInstance();
  static CLMSTokeValidate* default_instance_;
};
// -------------------------------------------------------------------

class SMSTokeValidate : public ::google::protobuf::MessageLite {
 public:
  SMSTokeValidate();
  virtual ~SMSTokeValidate();

  SMSTokeValidate(const SMSTokeValidate& from);

  inline SMSTokeValidate& operator=(const SMSTokeValidate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SMSTokeValidate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SMSTokeValidate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SMSTokeValidate* other);

  // implements Message ----------------------------------------------

  SMSTokeValidate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SMSTokeValidate& from);
  void MergeFrom(const SMSTokeValidate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline bool ret() const;
  inline void set_ret(bool value);

  // optional string GameID = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 2;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string pwd = 4;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 4;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // optional string nickName = 5;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 5;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:com.game.Protobuf.SMSTokeValidate)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* gameid_;
  ::std::string* account_;
  ::std::string* pwd_;
  ::std::string* nickname_;
  bool ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginServer_2eproto();
  friend void protobuf_ShutdownFile_LoginServer_2eproto();

  void InitAsDefaultInstance();
  static SMSTokeValidate* default_instance_;
};
// -------------------------------------------------------------------

class CMsgLogout : public ::google::protobuf::MessageLite {
 public:
  CMsgLogout();
  virtual ~CMsgLogout();

  CMsgLogout(const CMsgLogout& from);

  inline CMsgLogout& operator=(const CMsgLogout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CMsgLogout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgLogout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgLogout* other);

  // implements Message ----------------------------------------------

  CMsgLogout* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgLogout& from);
  void MergeFrom(const CMsgLogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.game.Protobuf.CMsgLogout)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_LoginServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_LoginServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_LoginServer_2eproto();
  friend void protobuf_ShutdownFile_LoginServer_2eproto();

  void InitAsDefaultInstance();
  static CMsgLogout* default_instance_;
};
// ===================================================================


// ===================================================================

// ServerT

// required int32 id = 1;
inline bool ServerT::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerT::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerT::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerT::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ServerT::id() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.ServerT.id)
  return id_;
}
inline void ServerT::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:com.game.Protobuf.ServerT.id)
}

// required string name = 2;
inline bool ServerT::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerT::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerT::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerT::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ServerT::name() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.ServerT.name)
  return *name_;
}
inline void ServerT::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.ServerT.name)
}
inline void ServerT::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.ServerT.name)
}
inline void ServerT::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.ServerT.name)
}
inline ::std::string* ServerT::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.ServerT.name)
  return name_;
}
inline ::std::string* ServerT::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerT::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.ServerT.name)
}

// required string ip = 3;
inline bool ServerT::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerT::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerT::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerT::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ServerT::ip() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.ServerT.ip)
  return *ip_;
}
inline void ServerT::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.ServerT.ip)
}
inline void ServerT::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.ServerT.ip)
}
inline void ServerT::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.ServerT.ip)
}
inline ::std::string* ServerT::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.ServerT.ip)
  return ip_;
}
inline ::std::string* ServerT::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerT::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.ServerT.ip)
}

// required int32 port = 4;
inline bool ServerT::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerT::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerT::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerT::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ServerT::port() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.ServerT.port)
  return port_;
}
inline void ServerT::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:com.game.Protobuf.ServerT.port)
}

// required int32 number = 5;
inline bool ServerT::has_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerT::set_has_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerT::clear_has_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerT::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 ServerT::number() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.ServerT.number)
  return number_;
}
inline void ServerT::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:com.game.Protobuf.ServerT.number)
}

// required int32 recommend = 6;
inline bool ServerT::has_recommend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerT::set_has_recommend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerT::clear_has_recommend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerT::clear_recommend() {
  recommend_ = 0;
  clear_has_recommend();
}
inline ::google::protobuf::int32 ServerT::recommend() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.ServerT.recommend)
  return recommend_;
}
inline void ServerT::set_recommend(::google::protobuf::int32 value) {
  set_has_recommend();
  recommend_ = value;
  // @@protoc_insertion_point(field_set:com.game.Protobuf.ServerT.recommend)
}

// -------------------------------------------------------------------

// CMsRequsetLogin

// required int32 loginType = 1;
inline bool CMsRequsetLogin::has_logintype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsRequsetLogin::set_has_logintype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsRequsetLogin::clear_has_logintype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsRequsetLogin::clear_logintype() {
  logintype_ = 0;
  clear_has_logintype();
}
inline ::google::protobuf::int32 CMsRequsetLogin::logintype() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRequsetLogin.loginType)
  return logintype_;
}
inline void CMsRequsetLogin::set_logintype(::google::protobuf::int32 value) {
  set_has_logintype();
  logintype_ = value;
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRequsetLogin.loginType)
}

// optional string account = 2;
inline bool CMsRequsetLogin::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsRequsetLogin::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsRequsetLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsRequsetLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CMsRequsetLogin::account() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRequsetLogin.account)
  return *account_;
}
inline void CMsRequsetLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRequsetLogin.account)
}
inline void CMsRequsetLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsRequsetLogin.account)
}
inline void CMsRequsetLogin::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsRequsetLogin.account)
}
inline ::std::string* CMsRequsetLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsRequsetLogin.account)
  return account_;
}
inline ::std::string* CMsRequsetLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsRequsetLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsRequsetLogin.account)
}

// optional string pwd = 3;
inline bool CMsRequsetLogin::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsRequsetLogin::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsRequsetLogin::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsRequsetLogin::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& CMsRequsetLogin::pwd() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRequsetLogin.pwd)
  return *pwd_;
}
inline void CMsRequsetLogin::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRequsetLogin.pwd)
}
inline void CMsRequsetLogin::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsRequsetLogin.pwd)
}
inline void CMsRequsetLogin::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsRequsetLogin.pwd)
}
inline ::std::string* CMsRequsetLogin::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsRequsetLogin.pwd)
  return pwd_;
}
inline ::std::string* CMsRequsetLogin::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsRequsetLogin::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsRequsetLogin.pwd)
}

// required string channelID = 4;
inline bool CMsRequsetLogin::has_channelid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsRequsetLogin::set_has_channelid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsRequsetLogin::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsRequsetLogin::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& CMsRequsetLogin::channelid() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRequsetLogin.channelID)
  return *channelid_;
}
inline void CMsRequsetLogin::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRequsetLogin.channelID)
}
inline void CMsRequsetLogin::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsRequsetLogin.channelID)
}
inline void CMsRequsetLogin::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsRequsetLogin.channelID)
}
inline ::std::string* CMsRequsetLogin::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsRequsetLogin.channelID)
  return channelid_;
}
inline ::std::string* CMsRequsetLogin::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsRequsetLogin::set_allocated_channelid(::std::string* channelid) {
  if (channelid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete channelid_;
  }
  if (channelid) {
    set_has_channelid();
    channelid_ = channelid;
  } else {
    clear_has_channelid();
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsRequsetLogin.channelID)
}

// optional string devicesID = 5;
inline bool CMsRequsetLogin::has_devicesid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsRequsetLogin::set_has_devicesid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsRequsetLogin::clear_has_devicesid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsRequsetLogin::clear_devicesid() {
  if (devicesid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicesid_->clear();
  }
  clear_has_devicesid();
}
inline const ::std::string& CMsRequsetLogin::devicesid() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRequsetLogin.devicesID)
  return *devicesid_;
}
inline void CMsRequsetLogin::set_devicesid(const ::std::string& value) {
  set_has_devicesid();
  if (devicesid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicesid_ = new ::std::string;
  }
  devicesid_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRequsetLogin.devicesID)
}
inline void CMsRequsetLogin::set_devicesid(const char* value) {
  set_has_devicesid();
  if (devicesid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicesid_ = new ::std::string;
  }
  devicesid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsRequsetLogin.devicesID)
}
inline void CMsRequsetLogin::set_devicesid(const char* value, size_t size) {
  set_has_devicesid();
  if (devicesid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicesid_ = new ::std::string;
  }
  devicesid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsRequsetLogin.devicesID)
}
inline ::std::string* CMsRequsetLogin::mutable_devicesid() {
  set_has_devicesid();
  if (devicesid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicesid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsRequsetLogin.devicesID)
  return devicesid_;
}
inline ::std::string* CMsRequsetLogin::release_devicesid() {
  clear_has_devicesid();
  if (devicesid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = devicesid_;
    devicesid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsRequsetLogin::set_allocated_devicesid(::std::string* devicesid) {
  if (devicesid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete devicesid_;
  }
  if (devicesid) {
    set_has_devicesid();
    devicesid_ = devicesid;
  } else {
    clear_has_devicesid();
    devicesid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsRequsetLogin.devicesID)
}

// optional string sex = 6;
inline bool CMsRequsetLogin::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsRequsetLogin::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsRequsetLogin::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsRequsetLogin::clear_sex() {
  if (sex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_->clear();
  }
  clear_has_sex();
}
inline const ::std::string& CMsRequsetLogin::sex() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRequsetLogin.sex)
  return *sex_;
}
inline void CMsRequsetLogin::set_sex(const ::std::string& value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRequsetLogin.sex)
}
inline void CMsRequsetLogin::set_sex(const char* value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsRequsetLogin.sex)
}
inline void CMsRequsetLogin::set_sex(const char* value, size_t size) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsRequsetLogin.sex)
}
inline ::std::string* CMsRequsetLogin::mutable_sex() {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsRequsetLogin.sex)
  return sex_;
}
inline ::std::string* CMsRequsetLogin::release_sex() {
  clear_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sex_;
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsRequsetLogin::set_allocated_sex(::std::string* sex) {
  if (sex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sex_;
  }
  if (sex) {
    set_has_sex();
    sex_ = sex;
  } else {
    clear_has_sex();
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsRequsetLogin.sex)
}

// optional string platform = 7;
inline bool CMsRequsetLogin::has_platform() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsRequsetLogin::set_has_platform() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsRequsetLogin::clear_has_platform() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsRequsetLogin::clear_platform() {
  if (platform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& CMsRequsetLogin::platform() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRequsetLogin.platform)
  return *platform_;
}
inline void CMsRequsetLogin::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRequsetLogin.platform)
}
inline void CMsRequsetLogin::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsRequsetLogin.platform)
}
inline void CMsRequsetLogin::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsRequsetLogin.platform)
}
inline ::std::string* CMsRequsetLogin::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsRequsetLogin.platform)
  return platform_;
}
inline ::std::string* CMsRequsetLogin::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsRequsetLogin::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsRequsetLogin.platform)
}

// required string verison = 8;
inline bool CMsRequsetLogin::has_verison() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsRequsetLogin::set_has_verison() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsRequsetLogin::clear_has_verison() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsRequsetLogin::clear_verison() {
  if (verison_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verison_->clear();
  }
  clear_has_verison();
}
inline const ::std::string& CMsRequsetLogin::verison() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRequsetLogin.verison)
  return *verison_;
}
inline void CMsRequsetLogin::set_verison(const ::std::string& value) {
  set_has_verison();
  if (verison_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verison_ = new ::std::string;
  }
  verison_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRequsetLogin.verison)
}
inline void CMsRequsetLogin::set_verison(const char* value) {
  set_has_verison();
  if (verison_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verison_ = new ::std::string;
  }
  verison_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsRequsetLogin.verison)
}
inline void CMsRequsetLogin::set_verison(const char* value, size_t size) {
  set_has_verison();
  if (verison_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verison_ = new ::std::string;
  }
  verison_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsRequsetLogin.verison)
}
inline ::std::string* CMsRequsetLogin::mutable_verison() {
  set_has_verison();
  if (verison_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verison_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsRequsetLogin.verison)
  return verison_;
}
inline ::std::string* CMsRequsetLogin::release_verison() {
  clear_has_verison();
  if (verison_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = verison_;
    verison_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsRequsetLogin::set_allocated_verison(::std::string* verison) {
  if (verison_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete verison_;
  }
  if (verison) {
    set_has_verison();
    verison_ = verison;
  } else {
    clear_has_verison();
    verison_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsRequsetLogin.verison)
}

// optional string nickName = 9;
inline bool CMsRequsetLogin::has_nickname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsRequsetLogin::set_has_nickname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsRequsetLogin::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsRequsetLogin::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& CMsRequsetLogin::nickname() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRequsetLogin.nickName)
  return *nickname_;
}
inline void CMsRequsetLogin::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRequsetLogin.nickName)
}
inline void CMsRequsetLogin::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsRequsetLogin.nickName)
}
inline void CMsRequsetLogin::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsRequsetLogin.nickName)
}
inline ::std::string* CMsRequsetLogin::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsRequsetLogin.nickName)
  return nickname_;
}
inline ::std::string* CMsRequsetLogin::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsRequsetLogin::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsRequsetLogin.nickName)
}

// -------------------------------------------------------------------

// CMsResponseLogin

// required string token = 1;
inline bool CMsResponseLogin::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsResponseLogin::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsResponseLogin::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsResponseLogin::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CMsResponseLogin::token() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsResponseLogin.token)
  return *token_;
}
inline void CMsResponseLogin::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsResponseLogin.token)
}
inline void CMsResponseLogin::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsResponseLogin.token)
}
inline void CMsResponseLogin::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsResponseLogin.token)
}
inline ::std::string* CMsResponseLogin::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsResponseLogin.token)
  return token_;
}
inline ::std::string* CMsResponseLogin::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsResponseLogin::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsResponseLogin.token)
}

// optional string account = 2;
inline bool CMsResponseLogin::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsResponseLogin::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsResponseLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsResponseLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CMsResponseLogin::account() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsResponseLogin.account)
  return *account_;
}
inline void CMsResponseLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsResponseLogin.account)
}
inline void CMsResponseLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsResponseLogin.account)
}
inline void CMsResponseLogin::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsResponseLogin.account)
}
inline ::std::string* CMsResponseLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsResponseLogin.account)
  return account_;
}
inline ::std::string* CMsResponseLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsResponseLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsResponseLogin.account)
}

// optional string pwd = 3;
inline bool CMsResponseLogin::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsResponseLogin::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsResponseLogin::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsResponseLogin::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& CMsResponseLogin::pwd() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsResponseLogin.pwd)
  return *pwd_;
}
inline void CMsResponseLogin::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsResponseLogin.pwd)
}
inline void CMsResponseLogin::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsResponseLogin.pwd)
}
inline void CMsResponseLogin::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsResponseLogin.pwd)
}
inline ::std::string* CMsResponseLogin::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsResponseLogin.pwd)
  return pwd_;
}
inline ::std::string* CMsResponseLogin::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsResponseLogin::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsResponseLogin.pwd)
}

// required string gameID = 4;
inline bool CMsResponseLogin::has_gameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsResponseLogin::set_has_gameid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsResponseLogin::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsResponseLogin::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& CMsResponseLogin::gameid() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsResponseLogin.gameID)
  return *gameid_;
}
inline void CMsResponseLogin::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsResponseLogin.gameID)
}
inline void CMsResponseLogin::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsResponseLogin.gameID)
}
inline void CMsResponseLogin::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsResponseLogin.gameID)
}
inline ::std::string* CMsResponseLogin::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsResponseLogin.gameID)
  return gameid_;
}
inline ::std::string* CMsResponseLogin::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsResponseLogin::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsResponseLogin.gameID)
}

// required string nickName = 5;
inline bool CMsResponseLogin::has_nickname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsResponseLogin::set_has_nickname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsResponseLogin::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsResponseLogin::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& CMsResponseLogin::nickname() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsResponseLogin.nickName)
  return *nickname_;
}
inline void CMsResponseLogin::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsResponseLogin.nickName)
}
inline void CMsResponseLogin::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CMsResponseLogin.nickName)
}
inline void CMsResponseLogin::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CMsResponseLogin.nickName)
}
inline ::std::string* CMsResponseLogin::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsResponseLogin.nickName)
  return nickname_;
}
inline ::std::string* CMsResponseLogin::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsResponseLogin::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsResponseLogin.nickName)
}

// repeated .com.game.Protobuf.ServerT serverlist = 6;
inline int CMsResponseLogin::serverlist_size() const {
  return serverlist_.size();
}
inline void CMsResponseLogin::clear_serverlist() {
  serverlist_.Clear();
}
inline const ::com::game::Protobuf::ServerT& CMsResponseLogin::serverlist(int index) const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsResponseLogin.serverlist)
  return serverlist_.Get(index);
}
inline ::com::game::Protobuf::ServerT* CMsResponseLogin::mutable_serverlist(int index) {
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsResponseLogin.serverlist)
  return serverlist_.Mutable(index);
}
inline ::com::game::Protobuf::ServerT* CMsResponseLogin::add_serverlist() {
  // @@protoc_insertion_point(field_add:com.game.Protobuf.CMsResponseLogin.serverlist)
  return serverlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::game::Protobuf::ServerT >&
CMsResponseLogin::serverlist() const {
  // @@protoc_insertion_point(field_list:com.game.Protobuf.CMsResponseLogin.serverlist)
  return serverlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::game::Protobuf::ServerT >*
CMsResponseLogin::mutable_serverlist() {
  // @@protoc_insertion_point(field_mutable_list:com.game.Protobuf.CMsResponseLogin.serverlist)
  return &serverlist_;
}

// -------------------------------------------------------------------

// CMsRegisterServer

// required .com.game.Protobuf.ServerT server = 1;
inline bool CMsRegisterServer::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsRegisterServer::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsRegisterServer::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsRegisterServer::clear_server() {
  if (server_ != NULL) server_->::com::game::Protobuf::ServerT::Clear();
  clear_has_server();
}
inline const ::com::game::Protobuf::ServerT& CMsRegisterServer::server() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRegisterServer.server)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return server_ != NULL ? *server_ : *default_instance().server_;
#else
  return server_ != NULL ? *server_ : *default_instance_->server_;
#endif
}
inline ::com::game::Protobuf::ServerT* CMsRegisterServer::mutable_server() {
  set_has_server();
  if (server_ == NULL) server_ = new ::com::game::Protobuf::ServerT;
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CMsRegisterServer.server)
  return server_;
}
inline ::com::game::Protobuf::ServerT* CMsRegisterServer::release_server() {
  clear_has_server();
  ::com::game::Protobuf::ServerT* temp = server_;
  server_ = NULL;
  return temp;
}
inline void CMsRegisterServer::set_allocated_server(::com::game::Protobuf::ServerT* server) {
  delete server_;
  server_ = server;
  if (server) {
    set_has_server();
  } else {
    clear_has_server();
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CMsRegisterServer.server)
}

// -------------------------------------------------------------------

// CMsRegisterServerRet

// required int32 ret = 1;
inline bool CMsRegisterServerRet::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsRegisterServerRet::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsRegisterServerRet::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsRegisterServerRet::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 CMsRegisterServerRet::ret() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsRegisterServerRet.ret)
  return ret_;
}
inline void CMsRegisterServerRet::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsRegisterServerRet.ret)
}

// -------------------------------------------------------------------

// CLMSTokeValidate

// required string token = 1;
inline bool CLMSTokeValidate::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CLMSTokeValidate::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CLMSTokeValidate::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CLMSTokeValidate::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CLMSTokeValidate::token() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CLMSTokeValidate.token)
  return *token_;
}
inline void CLMSTokeValidate::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CLMSTokeValidate.token)
}
inline void CLMSTokeValidate::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.CLMSTokeValidate.token)
}
inline void CLMSTokeValidate::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.CLMSTokeValidate.token)
}
inline ::std::string* CLMSTokeValidate::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.CLMSTokeValidate.token)
  return token_;
}
inline ::std::string* CLMSTokeValidate::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CLMSTokeValidate::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.CLMSTokeValidate.token)
}

// -------------------------------------------------------------------

// SMSTokeValidate

// required bool ret = 1;
inline bool SMSTokeValidate::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SMSTokeValidate::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SMSTokeValidate::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SMSTokeValidate::clear_ret() {
  ret_ = false;
  clear_has_ret();
}
inline bool SMSTokeValidate::ret() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.SMSTokeValidate.ret)
  return ret_;
}
inline void SMSTokeValidate::set_ret(bool value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:com.game.Protobuf.SMSTokeValidate.ret)
}

// optional string GameID = 2;
inline bool SMSTokeValidate::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SMSTokeValidate::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SMSTokeValidate::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SMSTokeValidate::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& SMSTokeValidate::gameid() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.SMSTokeValidate.GameID)
  return *gameid_;
}
inline void SMSTokeValidate::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.SMSTokeValidate.GameID)
}
inline void SMSTokeValidate::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.SMSTokeValidate.GameID)
}
inline void SMSTokeValidate::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.SMSTokeValidate.GameID)
}
inline ::std::string* SMSTokeValidate::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gameid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.SMSTokeValidate.GameID)
  return gameid_;
}
inline ::std::string* SMSTokeValidate::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SMSTokeValidate::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.SMSTokeValidate.GameID)
}

// optional string account = 3;
inline bool SMSTokeValidate::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SMSTokeValidate::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SMSTokeValidate::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SMSTokeValidate::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& SMSTokeValidate::account() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.SMSTokeValidate.account)
  return *account_;
}
inline void SMSTokeValidate::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.SMSTokeValidate.account)
}
inline void SMSTokeValidate::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.SMSTokeValidate.account)
}
inline void SMSTokeValidate::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.SMSTokeValidate.account)
}
inline ::std::string* SMSTokeValidate::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.SMSTokeValidate.account)
  return account_;
}
inline ::std::string* SMSTokeValidate::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SMSTokeValidate::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.SMSTokeValidate.account)
}

// optional string pwd = 4;
inline bool SMSTokeValidate::has_pwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SMSTokeValidate::set_has_pwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SMSTokeValidate::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SMSTokeValidate::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& SMSTokeValidate::pwd() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.SMSTokeValidate.pwd)
  return *pwd_;
}
inline void SMSTokeValidate::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.SMSTokeValidate.pwd)
}
inline void SMSTokeValidate::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.SMSTokeValidate.pwd)
}
inline void SMSTokeValidate::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.SMSTokeValidate.pwd)
}
inline ::std::string* SMSTokeValidate::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.SMSTokeValidate.pwd)
  return pwd_;
}
inline ::std::string* SMSTokeValidate::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SMSTokeValidate::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.SMSTokeValidate.pwd)
}

// optional string nickName = 5;
inline bool SMSTokeValidate::has_nickname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SMSTokeValidate::set_has_nickname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SMSTokeValidate::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SMSTokeValidate::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& SMSTokeValidate::nickname() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.SMSTokeValidate.nickName)
  return *nickname_;
}
inline void SMSTokeValidate::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:com.game.Protobuf.SMSTokeValidate.nickName)
}
inline void SMSTokeValidate::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.game.Protobuf.SMSTokeValidate.nickName)
}
inline void SMSTokeValidate::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.game.Protobuf.SMSTokeValidate.nickName)
}
inline ::std::string* SMSTokeValidate::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.game.Protobuf.SMSTokeValidate.nickName)
  return nickname_;
}
inline ::std::string* SMSTokeValidate::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SMSTokeValidate::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.game.Protobuf.SMSTokeValidate.nickName)
}

// -------------------------------------------------------------------

// CMsgLogout

// optional int32 ret = 1;
inline bool CMsgLogout::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgLogout::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgLogout::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgLogout::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 CMsgLogout::ret() const {
  // @@protoc_insertion_point(field_get:com.game.Protobuf.CMsgLogout.ret)
  return ret_;
}
inline void CMsgLogout::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:com.game.Protobuf.CMsgLogout.ret)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protobuf
}  // namespace game
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LoginServer_2eproto__INCLUDED
